{"version":3,"sources":["webpack:///./node_modules/@babel/runtime/helpers/esm/arrayWithoutHoles.js","webpack:///./node_modules/@babel/runtime/helpers/esm/iterableToArray.js","webpack:///./node_modules/@babel/runtime/helpers/esm/nonIterableSpread.js","webpack:///./node_modules/@babel/runtime/helpers/esm/toConsumableArray.js","webpack:///./src/Square.vue?ba8b","webpack:///./node_modules/@babel/runtime/helpers/esm/arrayWithHoles.js","webpack:///./node_modules/@babel/runtime/helpers/esm/iterableToArrayLimit.js","webpack:///./node_modules/@babel/runtime/helpers/esm/nonIterableRest.js","webpack:///./node_modules/@babel/runtime/helpers/esm/slicedToArray.js","webpack:///./src/Square.vue?8d85","webpack:///src/Square.vue","webpack:///./src/Square.vue?c5c7","webpack:///./src/Square.vue"],"names":["_arrayWithoutHoles","arr","Array","isArray","arrayLikeToArray","_iterableToArray","iter","Symbol","iterator","Object","from","_nonIterableSpread","TypeError","_toConsumableArray","arrayWithoutHoles","iterableToArray","unsupportedIterableToArray","nonIterableSpread","_arrayWithHoles","_iterableToArrayLimit","i","_arr","_n","_d","_e","undefined","_s","_i","next","done","push","value","length","err","_nonIterableRest","_slicedToArray","arrayWithHoles","iterableToArrayLimit","nonIterableRest","render","_vm","this","_h","$createElement","_c","_self","staticClass","_v","alives","generation","victories","ref","attrs","on","$event","type","indexOf","_k","keyCode","key","handleJumpTop","button","handleJumpRight","handleJumpBottom","handleJumpLeft","_l","cellValue","index","class","investigatedMaximumCellValue","maximumCellValue","actor","id","style","gridRow","y","gridColumn","x","refInFor","staticRenderFns","name","data","model","training","inputs","labels","learning","isDisplayingActors","actors","actorsCount","field","fieldSize","methods","setupModel","add","inputShape","activation","units","rate","compile","optimizer","loss","metrics","fieldSetting","Math","sqrt","max","$refs","container","setProperty","actorsReset","getRandomPredict","getDirectionStep","jumpRight","maximum","action","jumpBottom","jumpLeft","jumpTop","getAntennaCellValues","saveTraining","label","getBestMoves","forEach","firstCellValue","fiveCellValue","fourCellValue","thirdCellValue","secondCellValue","fiveIndex","fourIndex","thirdIndex","secondIndex","firstIndex","firstInput","firstLabel","secondInput","secondLabel","thirdInput","thirdLabel","fourInput","fourLabel","fiveInput","fiveLabel","component"],"mappings":"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","file":"js/chunk-1a489589.f982b936.js","sourcesContent":["import arrayLikeToArray from \"./arrayLikeToArray\";\nexport default function _arrayWithoutHoles(arr) {\n  if (Array.isArray(arr)) return arrayLikeToArray(arr);\n}","export default function _iterableToArray(iter) {\n  if (typeof Symbol !== \"undefined\" && Symbol.iterator in Object(iter)) return Array.from(iter);\n}","export default function _nonIterableSpread() {\n  throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}","import arrayWithoutHoles from \"./arrayWithoutHoles\";\nimport iterableToArray from \"./iterableToArray\";\nimport unsupportedIterableToArray from \"./unsupportedIterableToArray\";\nimport nonIterableSpread from \"./nonIterableSpread\";\nexport default function _toConsumableArray(arr) {\n  return arrayWithoutHoles(arr) || iterableToArray(arr) || unsupportedIterableToArray(arr) || nonIterableSpread();\n}","import mod from \"-!../node_modules/mini-css-extract-plugin/dist/loader.js??ref--6-oneOf-1-0!../node_modules/css-loader/dist/cjs.js??ref--6-oneOf-1-1!../node_modules/vue-loader/lib/loaders/stylePostLoader.js!../node_modules/postcss-loader/src/index.js??ref--6-oneOf-1-2!../node_modules/cache-loader/dist/cjs.js??ref--0-0!../node_modules/vue-loader/lib/index.js??vue-loader-options!./Square.vue?vue&type=style&index=0&id=69f9237b&scoped=true&lang=css&\"; export default mod; export * from \"-!../node_modules/mini-css-extract-plugin/dist/loader.js??ref--6-oneOf-1-0!../node_modules/css-loader/dist/cjs.js??ref--6-oneOf-1-1!../node_modules/vue-loader/lib/loaders/stylePostLoader.js!../node_modules/postcss-loader/src/index.js??ref--6-oneOf-1-2!../node_modules/cache-loader/dist/cjs.js??ref--0-0!../node_modules/vue-loader/lib/index.js??vue-loader-options!./Square.vue?vue&type=style&index=0&id=69f9237b&scoped=true&lang=css&\"","export default function _arrayWithHoles(arr) {\n  if (Array.isArray(arr)) return arr;\n}","export default function _iterableToArrayLimit(arr, i) {\n  if (typeof Symbol === \"undefined\" || !(Symbol.iterator in Object(arr))) return;\n  var _arr = [];\n  var _n = true;\n  var _d = false;\n  var _e = undefined;\n\n  try {\n    for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {\n      _arr.push(_s.value);\n\n      if (i && _arr.length === i) break;\n    }\n  } catch (err) {\n    _d = true;\n    _e = err;\n  } finally {\n    try {\n      if (!_n && _i[\"return\"] != null) _i[\"return\"]();\n    } finally {\n      if (_d) throw _e;\n    }\n  }\n\n  return _arr;\n}","export default function _nonIterableRest() {\n  throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}","import arrayWithHoles from \"./arrayWithHoles\";\nimport iterableToArrayLimit from \"./iterableToArrayLimit\";\nimport unsupportedIterableToArray from \"./unsupportedIterableToArray\";\nimport nonIterableRest from \"./nonIterableRest\";\nexport default function _slicedToArray(arr, i) {\n  return arrayWithHoles(arr) || iterableToArrayLimit(arr, i) || unsupportedIterableToArray(arr, i) || nonIterableRest();\n}","var render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('div',[_c('div',{staticClass:\"stat\"},[_vm._v(\" Живых: \"+_vm._s(_vm.alives)+\" | Поколений: \"+_vm._s(_vm.generation)+\" | Победы: \"+_vm._s(_vm.victories)+\" \")]),_c('div',{ref:\"container\",staticClass:\"container\",attrs:{\"tabindex\":\"0\"},on:{\"keyup\":[function($event){if(!$event.type.indexOf('key')&&_vm._k($event.keyCode,\"up\",38,$event.key,[\"Up\",\"ArrowUp\"])){ return null; }return _vm.handleJumpTop($event)},function($event){if(!$event.type.indexOf('key')&&_vm._k($event.keyCode,\"right\",39,$event.key,[\"Right\",\"ArrowRight\"])){ return null; }if('button' in $event && $event.button !== 2){ return null; }return _vm.handleJumpRight($event)},function($event){if(!$event.type.indexOf('key')&&_vm._k($event.keyCode,\"down\",40,$event.key,[\"Down\",\"ArrowDown\"])){ return null; }return _vm.handleJumpBottom($event)},function($event){if(!$event.type.indexOf('key')&&_vm._k($event.keyCode,\"left\",37,$event.key,[\"Left\",\"ArrowLeft\"])){ return null; }if('button' in $event && $event.button !== 0){ return null; }return _vm.handleJumpLeft($event)}]}},[_c('div',{staticClass:\"field cells\"},_vm._l((_vm.field),function(cellValue,index){return _c('div',{key:index,class:['cell', { 'available': cellValue !== 0 }]},[(cellValue === 1)?_c('div',{staticClass:\"starting-checkpoint\"},[_vm._v(\" 🥾 \")]):_vm._e(),(cellValue === _vm.investigatedMaximumCellValue\n            || _vm.investigatedMaximumCellValue === _vm.maximumCellValue)?_c('div',{staticClass:\"maximum-cell-value-checkpoint\"},[_vm._v(\" 🤘 \")]):_vm._e(),(cellValue === _vm.maximumCellValue)?_c('div',{staticClass:\"finishing-checkpoint\"},[_vm._v(\" 🧠 \")]):_vm._e()])}),0),(_vm.isDisplayingActors)?_c('div',{staticClass:\"field actors\"},_vm._l((_vm.actors),function(actor){return _c('div',{key:actor.id,style:({\n          gridRow: actor.y,\n          gridColumn: actor.x,\n        })},[_c('div',{ref:(\"actors_\" + (actor.id)),refInFor:true,staticClass:\"actor\"},[_c('div',[_vm._v(\"👣️\")])])])}),0):_vm._e()])])}\nvar staticRenderFns = []\n\nexport { render, staticRenderFns }","<template>\n  <div>\n    <div class=\"stat\">\n      Живых: {{ alives }} | Поколений: {{ generation }} | Победы: {{ victories }}\n    </div>\n\n    <div\n      ref=\"container\"\n      class=\"container\"\n      tabindex=\"0\"\n      @keyup.up=\"handleJumpTop\"\n      @keyup.right=\"handleJumpRight\"\n      @keyup.down=\"handleJumpBottom\"\n      @keyup.left=\"handleJumpLeft\"\n    >\n      <div class=\"field cells\">\n        <div\n          v-for=\"(cellValue, index) in field\"\n          :key=\"index\"\n          :class=\"['cell', { 'available': cellValue !== 0 }]\"\n        >\n          <div\n            v-if=\"cellValue === 1\"\n            class=\"starting-checkpoint\"\n          >\n            🥾\n          </div>\n\n          <div\n            v-if=\"cellValue === investigatedMaximumCellValue\n              || investigatedMaximumCellValue === maximumCellValue\"\n            class=\"maximum-cell-value-checkpoint\"\n          >\n            🤘\n          </div>\n\n          <div\n            v-if=\"cellValue === maximumCellValue\"\n            class=\"finishing-checkpoint\"\n          >\n            🧠\n          </div>\n        </div>\n      </div>\n\n      <div\n        v-if=\"isDisplayingActors\"\n        class=\"field actors\"\n      >\n        <div\n          v-for=\"actor in actors\"\n          :key=\"actor.id\"\n          :style=\"{\n            gridRow: actor.y,\n            gridColumn: actor.x,\n          }\"\n        >\n          <div\n            :ref=\"`actors_${actor.id}`\"\n            class=\"actor\"\n          >\n            <div>👣️</div>\n          </div>\n        </div>\n      </div>\n    </div>\n  </div>\n</template>\n\n<script>\nimport * as tf from '@tensorflow/tfjs';\n\nconst isAutomaticControl = true;\nconst isDisplayingActors = true;\n\nconst actorsCount = 500;\nconst researchActors = 5;\nconst everyNWillResearcher = actorsCount / researchActors;\nlet everyNWillResearcherCounter = 0;\n\n/* eslint-disable no-plusplus */\nexport default {\n  name: 'Square',\n\n  data() {\n    return {\n      model: tf.sequential(),\n      // Очищаемые перед следующим поколением накопленные данные агентов для обучения.\n      training: {\n        inputs: [],\n        labels: [],\n      },\n      // Лучшие агенты в поколении из training набора на которых будет обучаться модель.\n      learning: {\n        // x, y - Координаты актёра.\n        // cellValue - Значение ячейки, до которой агент дошёл.\n        inputs: [],\n        // [1, 0, 0, 0] - Пойти на север (north).\n        // [0, 1, 0, 0] - Пойти на восток (east).\n        // [0, 0, 1, 0] - Пойти на юг (south).\n        // [0, 0, 0, 1] - Пойти на запад (west).\n        labels: [],\n      },\n      generation: 0,\n      victories: 0,\n\n      isDisplayingActors,\n      // Набор генерируемых актёров.\n      actors: [],\n      // Количество актёров оставшихся в живых.\n      alives: actorsCount,\n      // Максимальное значение пройденной ячейки.\n      investigatedMaximumCellValue: 1,\n\n      // Игровая область обязательно квадратной формы под Math.sqrt.\n      // Обязательно между доступным путём, должно быть 2 запретных ячейки\n      // из за исследовательских \"усиков\".\n      // 0 - Запретная территория.\n      // [1..N) - Проходная территория.\n      // N - Финишная точка.\n      // @formatter:off\n      /* eslint-disable no-multi-spaces */\n      field: [\n        0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n        0,  1,  0,  0,  0,  0,  0,  0,  0, 45, 44, 43,  0,\n        0,  2,  0,  0,  0,  0,  0,  0,  0,  0,  0, 42,  0,\n        0,  3,  0,  0,  8,  9, 10, 11,  0,  0,  0, 41,  0,\n        0,  4,  5,  6,  7,  0,  0, 12,  0,  0,  0, 40,  0,\n        0,  0,  0,  0,  0,  0,  0, 13,  0,  0,  0, 39,  0,\n        0,  0,  0,  0,  0,  0, 15, 14,  0,  0,  0, 38,  0,\n        0,  0,  0,  0,  0,  0, 16,  0,  0,  0,  0, 37,  0,\n        0,  0, 21, 20, 19, 18, 17,  0,  0,  0,  0, 36,  0,\n        0,  0, 22,  0,  0,  0,  0,  0,  0, 33, 34, 35,  0,\n        0,  0, 23,  0,  0,  0,  0,  0,  0, 32,  0,  0,  0,\n        0,  0, 24, 25, 26, 27, 28, 29, 30, 31,  0,  0,  0,\n        0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n      ],\n      // @formatter:on\n      /* eslint-enable no-multi-spaces */\n      fieldSize: -1,\n      maximumCellValue: -1,\n    };\n  },\n\n  async mounted() {\n    this.setupModel();\n\n    this.fieldSetting();\n    await this.actorsSetting();\n\n    if (isAutomaticControl) {\n      await this.modelPredict();\n    }\n  },\n\n  methods: {\n    setupModel() {\n      this.model.add(tf.layers.dense({\n        // Описание в learning.inputs.\n        inputShape: [3],\n        activation: 'sigmoid',\n        units: 256,\n      }));\n\n      this.model.add(tf.layers.dropout({\n        rate: 0.1,\n      }));\n\n      this.model.add(tf.layers.dense({\n        activation: 'sigmoid',\n        units: 128,\n      }));\n\n      // this.model.add(tf.layers.dropout({\n      //   rate: 0.1,\n      // }));\n      //\n      // this.model.add(tf.layers.dense({\n      //   activation: 'sigmoid',\n      //   units: 32,\n      // }));\n\n      this.model.add(tf.layers.dense({\n        activation: 'sigmoid',\n        // [north, east, south, west] - Прогноз стороны для передвижения.\n        units: 4,\n      }));\n\n      this.model.compile({\n        optimizer: tf.train.adam(0.01),\n        loss: 'meanSquaredError',\n        metrics: ['accuracy'],\n      });\n    },\n\n    fieldSetting() {\n      this.fieldSize = Math.sqrt(this.field.length);\n      this.maximumCellValue = Math.max(...this.field);\n\n      this.$refs.container.style.setProperty('--quantity-rows', this.fieldSize);\n      this.$refs.container.style.setProperty('--quantity-columns', this.fieldSize);\n    },\n\n    async actorsSetting() {\n      for (let i = 0; i < actorsCount; i++) {\n        this.actors.push({\n          id: i,\n          style: undefined,\n\n          // Сбрасываемые.\n          x: 2,\n          y: 2,\n          cellValue: 1,\n        });\n      }\n\n      if (isDisplayingActors) {\n        await this.$nextTick();\n\n        this.actors.forEach((actor) => {\n          const [{ style }] = this.$refs[`actors_${actor.id}`];\n          actor.style = style;\n        });\n      }\n    },\n\n    actorsReset() {\n      for (let i = 0; i < actorsCount; i++) {\n        this.actors[i].x = 2;\n        this.actors[i].y = 2;\n        this.actors[i].cellValue = 1;\n      }\n\n      this.alives = actorsCount;\n    },\n\n    async modelPredict() {\n      await Promise.all(this.actors.map(async (actor) => {\n        if (actor.cellValue !== 0) {\n          let prediction;\n          everyNWillResearcherCounter += 1;\n\n          if (everyNWillResearcherCounter === everyNWillResearcher) {\n            prediction = this.getRandomPredict();\n            everyNWillResearcherCounter = 0;\n          } else {\n            prediction = await this.model.predict(tf.tensor2d([\n              [\n                actor.x / this.fieldSize,\n                actor.y / this.fieldSize,\n                actor.cellValue / this.maximumCellValue,\n              ],\n            ])).data();\n\n            // console.log(\n            //   'Top', prediction[0].toFixed(10),\n            //   'Right', prediction[1].toFixed(10),\n            //   'Bottom', prediction[2].toFixed(10),\n            //   'Left', prediction[3].toFixed(10),\n            // );\n          }\n\n          const directionStep = this.getDirectionStep(prediction);\n          this[directionStep](actor);\n\n          await this.availabilityCheck(actor);\n        }\n\n        // Замедление прогноза для каждого актёра.\n        // await new Promise((resolve) => {\n        //   setTimeout(() => {\n        //     resolve();\n        //   }, 1000);\n        // });\n      }));\n\n      await this.modelPredict();\n    },\n\n    // Создание случайных решений для исследователей.\n    getRandomPredict() {\n      return [\n        Math.random(), // jumpTop\n        Math.random(), // jumpRight\n        Math.random(), // jumpBottom\n        Math.random(), // jumpLeft\n      ];\n    },\n\n    getDirectionStep([jumpTop, jumpRight, jumpBottom, jumpLeft]) {\n      let maximum = jumpTop;\n      let action = 'jumpTop';\n\n      if (jumpRight > maximum) {\n        maximum = jumpRight;\n        action = 'jumpRight';\n      }\n\n      if (jumpBottom > maximum) {\n        maximum = jumpBottom;\n        action = 'jumpBottom';\n      }\n\n      if (jumpLeft > maximum) {\n        // maximum = jumpLeft;\n        action = 'jumpLeft';\n      }\n\n      return action;\n    },\n\n    jumpTop(actor) {\n      actor.y -= 1;\n    },\n\n    jumpRight(actor) {\n      actor.x += 1;\n    },\n\n    jumpBottom(actor) {\n      actor.y += 1;\n    },\n\n    jumpLeft(actor) {\n      actor.x -= 1;\n    },\n\n    async availabilityCheck(actor) {\n      // Смещение на -1: Сетка начинается с 1, а значения в массиве начинаются с 0.\n      const normalY = actor.y - 1;\n      const normalX = actor.x - 1;\n      const cellValue = this.field[normalY * this.fieldSize + normalX];\n\n      // Предотвращение зацикливания. Актёр не должен двигаться в обратном направлении.\n      if (cellValue > actor.cellValue) {\n        actor.cellValue = cellValue;\n\n        if (cellValue > this.investigatedMaximumCellValue) {\n          this.investigatedMaximumCellValue = cellValue;\n        }\n\n        if (cellValue === this.maximumCellValue) {\n          this.victories += 1;\n          await this.actorsReset();\n          return;\n        }\n      } else {\n        actor.cellValue = 0;\n        this.alives -= 1;\n      }\n\n      this.saveTraining({ actor, label: this.getAntennaCellValues({ normalX, normalY }) });\n\n      if (this.alives === 0) {\n        await this.modelFit();\n      }\n    },\n\n    // Получение значения ячейки, чем дальше ячейка от старта, тем больше там значение.\n    getAntennaCellValues({ normalX, normalY }) {\n      // 0 - когда выходит за пределы поля (дальше пути нет).\n      const topCellValue = this.field[(normalY - 1) * this.fieldSize + normalX] || 0;\n      const rightCellValue = this.field[normalY * this.fieldSize + (normalX + 1)] || 0;\n      const bottomCellValue = this.field[(normalY + 1) * this.fieldSize + normalX] || 0;\n      const leftCellValue = this.field[normalY * this.fieldSize + (normalX - 1)] || 0;\n\n      return [\n        topCellValue / this.maximumCellValue,\n        rightCellValue / this.maximumCellValue,\n        bottomCellValue / this.maximumCellValue,\n        leftCellValue / this.maximumCellValue,\n      ];\n    },\n\n    saveTraining({ actor, label }) {\n      this.training.inputs.push([\n        actor.x / this.fieldSize,\n        actor.y / this.fieldSize,\n        actor.cellValue / this.maximumCellValue,\n      ]);\n\n      this.training.labels.push(label);\n    },\n\n    async modelFit() {\n      const {\n        firstInput,\n        firstLabel,\n\n        secondInput,\n        secondLabel,\n\n        thirdInput,\n        thirdLabel,\n\n        fourInput,\n        fourLabel,\n\n        fiveInput,\n        fiveLabel,\n      } = this.getBestMoves();\n\n      this.learning.inputs.push(\n        firstInput,\n        secondInput,\n        thirdInput,\n        fourInput,\n        fiveInput,\n      );\n\n      this.learning.labels.push(\n        firstLabel,\n        secondLabel,\n        thirdLabel,\n        fourLabel,\n        fiveLabel,\n      );\n\n      await this.model.fit(\n        tf.tensor2d(this.learning.inputs),\n        tf.tensor2d(this.learning.labels),\n      );\n\n      this.generation += 1;\n      await this.actorsReset();\n    },\n\n    getBestMoves() {\n      const { inputs, labels } = this.training;\n      this.training = { inputs: [], labels: [] };\n\n      let fiveCellValue = -1;\n      let fourCellValue = -1;\n      let thirdCellValue = -1;\n      let secondCellValue = -1;\n      let firstCellValue = -1;\n\n      let fiveIndex = -1;\n      let fourIndex = -1;\n      let thirdIndex = -1;\n      let secondIndex = -1;\n      let firstIndex = -1;\n\n      inputs.forEach(([, , cellValue], index) => {\n        switch (true) {\n          case cellValue > firstCellValue:\n            fiveCellValue = fourCellValue;\n            fourCellValue = thirdCellValue;\n            thirdCellValue = secondCellValue;\n            secondCellValue = firstCellValue;\n            firstCellValue = cellValue;\n\n            fiveIndex = fourIndex;\n            fourIndex = thirdIndex;\n            thirdIndex = secondIndex;\n            secondIndex = firstIndex;\n            firstIndex = index;\n            break;\n\n          case cellValue > secondCellValue:\n            fiveCellValue = fourCellValue;\n            fourCellValue = thirdCellValue;\n            thirdCellValue = secondCellValue;\n            secondCellValue = cellValue;\n\n            fiveIndex = fourIndex;\n            fourIndex = thirdIndex;\n            thirdIndex = secondIndex;\n            secondIndex = index;\n            break;\n\n          case cellValue > thirdCellValue:\n            fiveCellValue = fourCellValue;\n            fourCellValue = thirdCellValue;\n            thirdCellValue = cellValue;\n\n            fiveIndex = fourIndex;\n            fourIndex = thirdIndex;\n            thirdIndex = index;\n            break;\n\n          case cellValue > fourCellValue:\n            fiveCellValue = fourCellValue;\n            fourCellValue = cellValue;\n\n            fiveIndex = fourIndex;\n            fourIndex = index;\n            break;\n\n          case cellValue > fiveCellValue:\n            fiveCellValue = cellValue;\n\n            fiveIndex = index;\n            break;\n\n          default:\n        }\n      });\n\n      return {\n        firstInput: inputs[firstIndex],\n        firstLabel: labels[firstIndex],\n\n        secondInput: inputs[secondIndex],\n        secondLabel: labels[secondIndex],\n\n        thirdInput: inputs[thirdIndex],\n        thirdLabel: labels[thirdIndex],\n\n        fourInput: inputs[fourIndex],\n        fourLabel: labels[fourIndex],\n\n        fiveInput: inputs[fiveIndex],\n        fiveLabel: labels[fiveIndex],\n      };\n    },\n\n    // Специально для ручного управления.\n    async handleJumpTop() {\n      const [actor] = this.actors;\n\n      this.jumpTop(actor);\n      await this.availabilityCheck(actor);\n    },\n\n    async handleJumpRight() {\n      const [actor] = this.actors;\n\n      this.jumpRight(actor);\n      await this.availabilityCheck(actor);\n    },\n\n    async handleJumpBottom() {\n      const [actor] = this.actors;\n\n      this.jumpBottom(actor);\n      await this.availabilityCheck(actor);\n    },\n\n    async handleJumpLeft() {\n      const [actor] = this.actors;\n\n      this.jumpLeft(actor);\n      await this.availabilityCheck(actor);\n    },\n  },\n};\n</script>\n\n<style scoped>\n.stat {\n  position: absolute;\n  margin-top: 1rem;\n  width: 100%;\n  text-align: center;\n  font-size: 1.2rem;\n  color: white;\n}\n\n.container {\n  --quantity-rows: -1;\n  --quantity-columns: -1;\n  --square-size: 3rem;\n\n  display: flex;\n  justify-content: center;\n  align-items: center;\n  height: 100vh;\n  outline: none;\n  user-select: none;\n}\n\n.field {\n  display: grid;\n  grid-template-rows: repeat(var(--quantity-rows), var(--square-size));\n  grid-template-columns: repeat(var(--quantity-columns), var(--square-size));\n  grid-gap: 0.5rem;\n}\n\n.cells {\n}\n\n.cell {\n  position: relative;\n  background-color: #222;\n}\n\n.available {\n  background-color: darkcyan;\n}\n\n.starting-checkpoint,\n.maximum-cell-value-checkpoint,\n.finishing-checkpoint {\n  position: absolute;\n  display: flex;\n  justify-content: center;\n  align-items: center;\n  width: 100%;\n  height: 100%;\n  font-size: 2rem;\n  background-color: seagreen;\n  outline: 0.5rem dashed seagreen;\n}\n\n.maximum-cell-value-checkpoint {\n  background-color: brown;\n  outline: 0.5rem dashed brown;\n}\n\n.actors {\n  position: absolute;\n}\n\n.actor {\n  height: 100%;\n  text-align: center;\n  font-size: 2rem;\n}\n</style>\n","import mod from \"-!../node_modules/cache-loader/dist/cjs.js??ref--12-0!../node_modules/thread-loader/dist/cjs.js!../node_modules/babel-loader/lib/index.js!../node_modules/cache-loader/dist/cjs.js??ref--0-0!../node_modules/vue-loader/lib/index.js??vue-loader-options!./Square.vue?vue&type=script&lang=js&\"; export default mod; export * from \"-!../node_modules/cache-loader/dist/cjs.js??ref--12-0!../node_modules/thread-loader/dist/cjs.js!../node_modules/babel-loader/lib/index.js!../node_modules/cache-loader/dist/cjs.js??ref--0-0!../node_modules/vue-loader/lib/index.js??vue-loader-options!./Square.vue?vue&type=script&lang=js&\"","import { render, staticRenderFns } from \"./Square.vue?vue&type=template&id=69f9237b&scoped=true&\"\nimport script from \"./Square.vue?vue&type=script&lang=js&\"\nexport * from \"./Square.vue?vue&type=script&lang=js&\"\nimport style0 from \"./Square.vue?vue&type=style&index=0&id=69f9237b&scoped=true&lang=css&\"\n\n\n/* normalize component */\nimport normalizer from \"!../node_modules/vue-loader/lib/runtime/componentNormalizer.js\"\nvar component = normalizer(\n  script,\n  render,\n  staticRenderFns,\n  false,\n  null,\n  \"69f9237b\",\n  null\n  \n)\n\nexport default component.exports"],"sourceRoot":""}